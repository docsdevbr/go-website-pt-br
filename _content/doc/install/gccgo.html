<!--
Copyright (c) 2009 The Go Authors.

Documentation licensed under the 3-Clause BSD License.
The original work was translated from English into Brazilian Portuguese.
https://github.com/golang/website/blob/master/LICENSE

source_url: https://github.com/golang/website/blob/master/_content/doc/install/gccgo.html
revision: 710879a47fca2836605609629f31217932f5efd0
status: ready
-->

<!--{
	"Title": "Configurando e usando o gccgo",
	"Breadcrumb": true
}-->

<p>
  Este documento explica como usar o gccgo, um compilador para a linguagem Go.
  O compilador gccgo é um novo frontend para o GCC, o compilador GNU amplamente
  utilizado.
  Embora o frontend em si esteja sob uma licença no estilo BSD, o gccgo é
  normalmente usado como parte do GCC e, portanto, coberto pela
  <a href="https://www.gnu.org/licenses/gpl.html">Licença Pública Geral GNU</a>
  (a licença abrange o próprio gccgo como parte do GCC; ela não abrange o código
  gerado pelo gccgo).
</p>

<p>
  Observe que o gccgo não é o compilador <code>gc</code>; consulte as instruções
  de <a href="/doc/install">Instalando o Go</a> para esse compilador.
</p>

<h2 id="Releases">Versões</h2>

<p>
  A maneira mais simples de instalar o gccgo é instalar uma versão binária do
  GCC compilada para incluir suporte a Go.
  As versões binárias do GCC estão disponíveis em
  <a href="https://gcc.gnu.org/install/binaries.html">vários sites</a> e
  normalmente são incluídas como parte de distribuições GNU/Linux.
  Esperamos que a maioria das pessoas que criam esses binários incluam suporte a
  Go.
</p>

<p>
  A versão 4.7.1 do GCC e todas as versões 4.7 posteriores incluem um compilador
  e bibliotecas <a href="/doc/go1.html">Go 1</a> completos.
</p>

<p>
  Devido ao tempo, as versões 4.8.0 e 4.8.1 do GCC são próximas, mas não
  idênticas, à versão 1.1.
  A versão 4.8.2 do GCC inclui uma implementação completa do Go 1.1.2.
</p>

<p>
  As versões do GCC 4.9 incluem uma implementação completa do Go 1.2.
</p>

<p>
  As versões do GCC 5 incluem uma implementação completa das bibliotecas de
  pessoa usuária do Go 1.4.
  O runtime do Go 1.4 não está totalmente integrado, mas isso não deve ser
  visível para programas em Go.
</p>

<p>
  As versões do GCC 6 incluem uma implementação completa das bibliotecas de
  usuário do Go 1.6.1.
  O tempo de execução do Go 1.6 não está totalmente integrado, mas isso não deve
  ser visível para programas em Go.
</p>

<p>
  As versões do GCC 7 incluem uma implementação completa das bibliotecas de
  usuário do Go 1.8.1.
  Assim como nas versões anteriores, o runtime do Go 1.8 não está totalmente
  integrado, mas isso não deve ser visível para programas em Go.
</p>

<p>
  As versões do GCC 8 incluem uma implementação completa da versão do Go 1.10.1.
  O runtime do Go 1.10 agora foi totalmente integrado ao código-fonte de
  desenvolvimento do GCC, e a coleta de lixo simultânea é totalmente suportada.
</p>

<p>
  As versões do GCC 9 incluem uma implementação completa da versão do Go 1.12.2.
</p>

<p>
  As versões do GCC 10 incluem uma implementação completa da versão Go 1.14.6.
</p>

<p>
  As versões do GCC 11 incluem uma implementação completa da versão Go 1.16.3.
</p>

<p>
  As versões do GCC 12 e 13 incluem uma implementação completa da biblioteca
  padrão Go 1.18.
  No entanto, o GCC ainda não inclui suporte para generics.
</p>

<h2 id="Source_code">Código-fonte</h2>

<p>
  Se você não puder usar um lançamento ou preferir compilar o gccgo por conta
  própria, o código-fonte do gccgo pode ser acessado via Git.
  O site do GCC possui
  <a href="https://gcc.gnu.org/git.html">
    instruções para obter o código-fonte do GCC
  </a>.
  O código-fonte do gccgo está incluído.
  Para sua conveniência, uma versão estável do suporte a Go está disponível no
  branch <code>devel/gccgo</code> do repositório principal de código do GCC:
  <code>git://gcc.gnu.org/git/gcc.git</code>.
  Este branch é atualizado periodicamente com fontes estáveis do compilador Go.
</p>

<p>
  Observe que, embora <code>gcc.gnu.org</code> seja a maneira mais conveniente
  de obter o código-fonte para o frontend Go, não é onde o código-fonte
  principal fica.
  Se você quiser contribuir com alterações no compilador frontend do Go,
  consulte <a href="/doc/gccgo_contribute.html">Contribuindo para o gccgo</a>.
</p>

<h2 id="Building">Compilando</h2>

<p>
  Compilar o gccgo é como compilar o GCC com uma ou duas opções adicionais.
  Consulte as
  <a href="https://gcc.gnu.org/install/">instruções no site do gcc</a>.
  Ao executar <code>configure</code>, adicione a opção
  <code>--enable-languages=c,c++,go</code> (junto com outras linguagens que você
  queira compilar).
  Se você tem como alvo um x86 de 32 bits, então você vai querer compilar o
  gccgo para que, por padrão, suporte a instruções de comparação e troca
  bloqueadas; faça isso também usando a opção <code>configure</code>
  <code>--with-arch=i586</code> (ou uma arquitetura mais recente, dependendo de
  onde você precisa que seus programas sejam executados).
  Se você tem como alvo um x86 de 64 bits, mas às vezes deseja usar a opção
  <code>-m32</code>, use a opção <code>configure</code>
  <code>--with-arch-32=i586</code>.
</p>

<h3 id="Gold">Gold</h3>

<p>
  Em sistemas GNU/Linux x86, o compilador gccgo é capaz de usar uma pequena
  pilha descontínua para goroutines.
  Isso permite que os programas executem muito mais goroutines, já que cada
  goroutine pode usar uma pilha relativamente pequena.
  Para isso, é necessário usar o gold linker versão 2.22 ou posterior.
  Você pode instalar o GNU binutils 2.22 ou posterior ou pode compilar o gold
  você mesmo.
</p>

<p>
  Para compilar o gold você mesmo, compile o GNU binutils usando
  <code>--enable-gold=default</code> ao executar o script
  <code>configure</code>.
  Antes de compilar, você deve instalar os pacotes flex e bison.
  Uma sequência típica seria algo como esta (você pode substituir
  <code>/opt/gold</code> por qualquer diretório ao qual você tenha acesso de
  gravação):
</p>

<pre>
git clone git://sourceware.org/git/binutils-gdb.git
mkdir binutils-objdir
cd binutils-objdir
../binutils-gdb/configure --enable-gold=default --prefix=/opt/gold
make
make install
</pre>

<p>
  Independentemente de como você instalar o gold, ao configurar o gccgo, use a
  opção <code>--with-ld=<var>GOLD_BINARY</var></code>.
</p>

<h3 id="Prerequisites">Pré-requisitos</h3>

<p>
  Vários pré-requisitos são necessários para compilar o GCC, conforme descrito
  no <a href="https://gcc.gnu.org/install/prerequisites.html">site do gcc</a>.
  É importante instalar todos os pré-requisitos antes de executar o script
  <code>configure</code> do gcc.
  As bibliotecas pré-requisitos podem ser baixadas facilmente usando o script
  <code>contrib/download_prerequisites</code> nos códigos-fonte do GCC.
</p>

<h3 id="Build_commands">Comandos de compilação</h3>

<p>
  Depois que todos os pré-requisitos estiverem instalados, uma sequência típica
  de compilação e instalação ficaria assim (use a opção <code>--with-ld</code>
  somente se estiver usando o gold linker, conforme descrito acima):
</p>

<pre>
git clone --branch devel/gccgo git://gcc.gnu.org/git/gcc.git gccgo
mkdir objdir
cd objdir
../gccgo/configure --prefix=/opt/gccgo --enable-languages=c,c++,go --with-ld=/opt/gold/bin/ld
make
make install
</pre>

<h2 id="Using_gccgo">Usando o gccgo</h2>

<p>
  O compilador gccgo funciona como outros frontends do GCC.
  A partir do GCC 5, a instalação do gccgo também inclui uma versão do comando
  <code>go</code>, que pode ser usado para compilar programas em Go, conforme
  descrito em <a href="/cmd/go">https://go.dev/cmd/go</a>.
</p>

<p>
  Para compilar um arquivo sem usar o comando <code>go</code>:
</p>

<pre>
gccgo -c file.go
</pre>

<p>
  Isso produz <code>file.o</code>.
  Para vincular os arquivos e formar um executável:
</p>

<pre>
gccgo -o file file.o
</pre>

<p>
  Para executar o arquivo resultante, você precisará informar ao programa onde
  encontrar os pacotes Go compilados.
  Há algumas maneiras de fazer isso:
</p>

<ul>
  <li>
    <p>
      Defina a variável de ambiente <code>LD_LIBRARY_PATH</code>:
    </p>

    <pre>
    LD_LIBRARY_PATH=${prefix}/lib/gcc/MACHINE/VERSION
    [ou]
    LD_LIBRARY_PATH=${prefix}/lib64/gcc/MACHINE/VERSION
    export LD_LIBRARY_PATH
    </pre>

    <p>
      Aqui, <code>${prefix}</code> é a opção <code>--prefix</code> usada ao compilar
      o gccgo.
      Para uma instalação binária, isso é normalmente <code>/usr</code>.
      Usar <code>lib</code> ou <code>lib64</code> depende do alvo.
      Normalmente, <code>lib64</code> é o correto para sistemas x86_64, e
      <code>lib</code> é o correto para outros sistemas.
      A ideia é nomear o diretório onde <code>libgo.so</code> se encontra.
    </p>
  </li>

  <li>
    <p>
      Passando a opção <code>-Wl,-R</code> ao fazer uma vinculação (substitua
      lib por lib64 se apropriado para o seu sistema):
    </p>

    <pre>
    go build -gccgoflags -Wl,-R,${prefix}/lib/gcc/MACHINE/VERSION
    [ou]
    gccgo -o file file.o -Wl,-R,${prefix}/lib/gcc/MACHINE/VERSION
    </pre>
  </li>

  <li>
    <p>
      Use a opção <code>-static-libgo</code> para vincular estaticamente os
      pacotes compilados.
    </p>
  </li>

  <li>
    <p>
      Use a opção <code>-static</code> para fazer uma vinculação totalmente
      estática (o padrão para o compilador <code>gc</code>).
    </p>
  </li>
</ul>

<h2 id="Options">Opções</h2>

<p>
  O compilador gccgo suporta todas as opções do GCC que são independentes de
  linguagem, notavelmente as opções <code>-O</code> e <code>-g</code>.
</p>

<p>
  A opção <code>-fgo-pkgpath=PKGPATH</code> pode ser usada para definir um
  prefixo exclusivo para o pacote que está sendo compilado.
  Esta opção é usada automaticamente pelo comando go, mas você pode querer
  usá-la se invocar o gccgo diretamente.
  Esta opção destina-se ao uso com programas grandes que contêm muitos pacotes,
  a fim de permitir que vários pacotes usem o mesmo identificador que o nome do
  pacote.
  O <code>PKGPATH</code> pode ser qualquer string; uma boa escolha para a string
  é o caminho usado para importar o pacote.
</p>

<p>
  As opções <code>-I</code> e <code>-L</code>, que são sinônimos para o
  compilador, podem ser usadas para definir o caminho de busca para encontrar
  importações.
  Essas opções não são necessárias se você compilar com o comando go.
</p>

<h2 id="Imports">Importações</h2>

<p>
  Ao compilar um arquivo que exporta algo, as informações de exportação serão
  armazenadas diretamente no arquivo objeto.
  Se você compilar diretamente com o gccgo, em vez de usar o comando go, ao
  importar um pacote, você deverá informar ao gccgo como encontrar o arquivo.
</p>

<p>
  Ao importar o pacote <var>FILE</var> com o gccgo, ele procurará os dados de
  importação nos arquivos seguintes e usará o primeiro que encontrar.
</p>

<ul>
  <li><code><var>FILE</var>.gox</code>
  <li><code>lib<var>FILE</var>.so</code>
  <li><code>lib<var>FILE</var>.a</code>
  <li><code><var>FILE</var>.o</code>
</ul>

<p>
  <code><var>FILE</var>.gox</code>, quando usado, normalmente conterá nada além
  de dados de exportação.
  Isso pode ser gerado a partir de <code><var>FILE</var>.o</code> via:
</p>

<pre>
objcopy -j .go_export FILE.o FILE.gox
</pre>

<p>
  O compilador gccgo procurará no diretório atual por arquivos de importação.
  Em cenários mais complexos, você pode passar a opção <code>-I</code> ou
  <code>-L</code> para o gccgo.
  Ambas as opções recebem diretórios para pesquisa.
  A opção <code>-L</code> também é passada para o vinculador.
</p>

<p>
  O compilador gccgo não registra atualmente (15/06/2015) o nome do arquivo dos
  pacotes importados no arquivo objeto.
  Você deve organizar para que os dados importados sejam vinculados ao programa.
  Novamente, isso não é necessário ao compilar com o comando go.
</p>

<pre>
gccgo -c meupacote.go              # Exporta meupacote
gccgo -c main.go                   # Importa meupacote
gccgo -o main main.o meupacote.o   # Vincula explicitamente com meupacote.o
</pre>

<h2 id="Debugging">Depurando</h2>

<p>
  Se você usar a opção <code>-g</code> ao compilar, poderá executar
  o <code>gdb</code> no seu executável.
  O depurador tem conhecimento limitado sobre Go.
  Você pode definir pontos de interrupção, etapas únicas, etc.
  Você pode imprimir variáveis, mas elas serão impressas como se tivessem tipos
  C/C++.
  Para tipos numéricos, isso não importa.
  Strings e interfaces em Go serão exibidas como estruturas de dois elementos.
  Mapas e channels em Go são sempre representados como ponteiros C para
  estruturas do runtime.
</p>

<h2 id="C_Interoperability">Interoperabilidade em C</h2>

<p>
  Ao usar o gccgo, a interoperabilidade com C ou com código C++ compilado usando
  <code>extern "C"</code> é limitada.
</p>

<h3 id="Types">Tipos</h3>

<p>
  Tipos básicos são mapeados diretamente: um <code>int32</code> em Go é um
  <code>int32_t</code> em C, um <code>int64</code> é um <code>int64_t</code>,
  etc.
  O tipo <code>int</code> em Go é um inteiro com o mesmo tamanho de um ponteiro
  e, como tal, corresponde ao tipo <code>intptr_t</code> em C.
  <code>byte</code> em Go é equivalente a <code>unsigned char</code> em C.
  Ponteiros em Go são ponteiros em C.
  Uma <code>struct</code> em Go é o mesmo que uma <code>struct</code> em C, com
  os mesmos campos e tipos.
</p>

<p>
  O tipo <code>string</code> em Go é atualmente definido como uma estrutura de
  dois elementos (isso está <b style="color: red;">sujeito a alterações</b>):
</p>

<pre>
struct __go_string {
  const unsigned char *__data;
  intptr_t __length;
};
</pre>

<p>
  Você não pode passar arrays entre C e Go.
  No entanto, um ponteiro para um array em Go é equivalente a um ponteiro em C
  para o equivalente do tipo de elemento.
  Por exemplo, Go <code>*[10]int</code> é equivalente a C <code>int*</code>,
  assumindo que o ponteiro em C aponta para 10 elementos.
</p>

<p>
  Uma slice em Go é uma estrutura.
  A definição atual é (isso
  <b style="color: red;">está sujeito a alterações</b>):
</p>

<pre>
struct __go_slice {
  void *__values;
  intptr_t __count;
  intptr_t __capacity;
};
</pre>

<p>
  O tipo de uma função Go é um ponteiro para uma struct (isso está
  <b style="color: red;">sujeito a alterações</b>).
  O primeiro campo na struct aponta para o código da função, que será
  equivalente a um ponteiro para uma função C cujos tipos de parâmetros são
  equivalentes, com um parâmetro final adicional.
  O parâmetro final é o closure, e o argumento a ser passado é um ponteiro para
  a struct da função Go.
  Quando uma função Go retorna mais de um valor, a função C retorna uma struct.
  Por exemplo, estas funções são aproximadamente equivalentes:
</p>

<pre>
func GoFunction(int) (int, float64)
struct { int i; float64 f; } CFunction(int, void*)
</pre>

<p>
  Os tipos <code>interface</code>, <code>channel</code> e <code>map</code> em Go
  não possuem um tipo C correspondente (<code>interface</code> é uma struct de
  dois elementos e <code>channel</code> e <code>map</code> são ponteiros para
  structs em C, mas as structs são deliberadamente não documentadas).
  Os tipos <code>enum</code> em C correspondem a algum tipo inteiro, mas
  precisamente qual deles é difícil de prever em geral; use um cast.
  Os tipos <code>union</code> em C não possuem um tipo Go correspondente.
  Os tipos <code>struct</code> em C contendo campos de bits não possuem um tipo
  Go correspondente.
  Os tipos <code>class</code> em C++ não possuem um tipo Go correspondente.
</p>

<p>
  A alocação de memória é completamente diferente entre C e Go, pois Go usa
  coleta de lixo.
  As diretrizes exatas nesta área são indeterminadas, mas é provável que seja
  permitido passar um ponteiro para a memória alocada de C para Go.
  A responsabilidade de eventualmente liberar o ponteiro permanecerá com o lado
  C e, claro, se o lado C liberar o ponteiro enquanto o lado Go ainda tiver uma
  cópia, o programa falhará.
  Ao passar um ponteiro de Go para C, a função Go deve manter uma cópia visível
  dele em alguma variável Go.
  Caso contrário, o coletor de lixo de Go pode excluir o ponteiro enquanto a
  função C ainda o estiver usando.
</p>

<h3 id="Function_names">Nomes de funções</h3>

<p>
  O código Go pode chamar funções C diretamente usando uma extensão Go
  implementada em gccgo: uma declaração de função pode ser precedida por
  <code>//extern NAME</code>.
  Por exemplo, aqui está como a função C <code>open</code> pode ser declarada em
  Go:
</p>

<pre>
//extern open
func c_open(name *byte, mode int, perm int) int
</pre>

<p>
  A função C naturalmente espera uma string terminada em NUL, que em Go é
  equivalente a um ponteiro para um array (não uma slice!) de <code>byte</code>
  com um byte final zero.
  Portanto, um exemplo de chamada em Go ficaria assim (após importar o pacote
  <code>syscall</code>):
</p>

<pre>
var name = [4]byte{'f', 'o', 'o', 0};
i := c_open(&amp;name[0], syscall.O_RDONLY, 0);
</pre>

<p>
  (Isto serve apenas como exemplo; para abrir um arquivo em Go, use a função
  <code>os.Open</code> do Go).
</p>

<p>
  Observe que, se a função C puder bloquear, como em uma chamada para
  <code>read</code>, chamar a função C poderá bloquear o programa em Go.
  A menos que você tenha uma compreensão clara do que está fazendo, todas as
  chamadas entre C e Go devem ser implementadas por meio de cgo ou SWIG, como
  para o compilador <code>gc</code>.
</p>

<p>
  O nome das funções em Go acessadas em C está sujeito a alterações.
  Atualmente, o nome de uma função em Go que não possui um receptor é
  <code>prefixo.pacote.NomeDaFunção</code>.
  O prefixo é definido pela opção <code>-fgo-prefix</code> usada quando o pacote
  é compilado; se a opção não for usada, o padrão é <code>go</code>.
  Para chamar a função a partir do C, você deve definir o nome usando uma
  extensão do GCC.
</p>

<pre>
extern int go_function(int) __asm__ ("prefixo.pacote.NomeDaFunção");
</pre>

<h3 id="Automatic_generation_of_Go_declarations_from_C_source_code">
  Geração automática de declarações Go a partir do código-fonte C
</h3>

<p>
  A versão Go do GCC suporta a geração automática de declarações Go a partir do
  código C.
  O recurso é um tanto inconveniente, e a maioria das pessoas usuárias deve usar
  o programa <a href="/cmd/cgo">cgo</a> com a opção <code>-gccgo</code>.
</p>

<p>
  Compile seu código C normalmente e adicione a opção
  <code>-fdump-go-spec=<var>FILENAME</var></code>.
  Isso criará o arquivo <code><var>FILENAME</var></code> como um efeito
  colateral da compilação.
  Este arquivo conterá declarações em Go para os tipos, variáveis e funções
  declaradas no código C.
  Tipos em C que não podem ser representados em Go serão registrados como
  comentários no código Go.
  O arquivo gerado não terá uma declaração de <code>package</code>, mas pode ser
  compilado diretamente pelo gccgo.
</p>

<p>
  Este procedimento está cheio de ressalvas e restrições não declaradas e não
  oferecemos nenhuma garantia de que ele não será alterado no futuro.
  Ele é mais útil como ponto de partida para código Go real do que como um
  procedimento regular.
</p>
